knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidyverse)
libary(here)
library(here)
file<-here('kaggle_files','train.csv')
df<-read.csv(file)
View(df)
View(df)
df$totals[1]
View(df)
df.colnames
df.columns
df.columns()
columns(df)
colnames(df)
levels(channelGrouping)
levels(as.factor(channelGrouping))
levels(as.factor(df$channelGrouping))
summary(df$channelGrouping)
df$channelGrouping<-as.factor(channelGrouping)
df$channelGrouping<-as.factor(df$channelGrouping)
View(df)
df$totals[1:10]
df$totals.unique()
unique(df$totals)
df$totals[73]
df$totals[74]
df_transaction<-df%>%filter(str_detect(totals,'transaction'))
df$totals[1:10]
df_transaction$totals[1:10]
library(tidyverse)
library(stringr)
string1<-"This is a string"
string2<-'To put a "quote" inside a string, use single quotes'
double_quote <- "\"" # or '"'
single_quote <- '\'' # or "'"
#literal backslash
x<-c("\"","\\")
#printed representation of a string is not the same as the string itself, try printing x and then using writeLines(x)
x
writeLines(x)
str_c("x","y")
str_c("x","y","z")
#control how they are separated
str_c("x","y","z",sep = ", ")
#if you want to print Missing values as NA, use str_replace_na()
x<-c("abc", NA)
str_c("|-", x, "-|")
str_c("|-", str_replace_na(x),"-|")
str_to_upper(c("i", "ı"))#dotless i
str_to_upper(c("i", "ı"), locale = "tr")
x <- c("a", "b", "c", "d")
y <- c("w", "x", "y", "z")
paste(x,y,sep = "%%")
paste(x,y,sep="%%",collapse ="," )
paste(x,y,sep = ",",collapse = "%%")
x<-"ten4ten"
str_length(x)
x <- "heyho I am a very long string"    # Create a character string
str_wrap(x, 10)
thanks_path <- file.path(R.home("doc"), "THANKS")
thanks <- str_c(readLines(thanks_path), collapse = "\n")
thanks <- word(thanks, 1, 3, fixed("\n\n"))
cat(str_wrap(thanks), "\n")
cat(str_wrap(thanks, width = 40), "\n")
cat(str_wrap(thanks, width = 60, indent = 2), "\n")
cat(str_wrap(thanks, width = 60, exdent = 2), "\n")
cat(str_wrap(thanks, width = 0, exdent = 2), "\n")
x <- c("apple", "banana", "pear")
str_view(x, "an")
#Matches any character EXCEPT a newline
str_view(x,".a.")
#Matching a period
#Use regexp \. to indicate the character period and not its special behavior
#need to use \\. to escape the STRING and then ESCAPE the special behavior of the period
dot<-"\\."
writeLines(dot)
#Look for an explicit (will find a.c. )
str_view(c("abc","a.c","bef"), "a\\.c")
#Match literal backslash "\"
#need to write "\\\\"
x<-"a\"\'\\b"
writeLines(x)
str_view(x,"\"\'\\\\")
dict_to_df = function(dict) {
require(plyr)
df = data.frame()
df_temp = list()
store = list()
for (i in 1:length(dict)) {
# Split up the dictionary entry
split = unlist(strsplit(dict[i], '\",'))
split = gsub('\\{', '', split)
split = gsub('\\}', '', split)
values = unlist(strsplit(split, ':'))
# Parse out what will be the df headers
headers = values[seq(1, length(values), 2)]
headers = gsub('\"', '', headers) # Remove quotes
headers = gsub(' ', '', headers)  # and whitespace
# Parse out what will be the df values
row_values = values[seq(0, length(values), 2)]
row_values = gsub('\"', '', row_values) # Remove quotes
row_values = gsub(' ', '', row_values)  # and whitespace
# Construct a dataframe with 1 row
out = data.frame(t(row_values))
colnames(out) = headers
store[i] = list(out)
if (i %% 1000 == 0) { print(round(i / length(dict), 2)) }
}
# rbind all the dataframes together into one dataframe
list_length = length(store)
# If the dictionary is sufficiently large rbind will be slow
# as all hell, so break the rbinding into multiple steps
if (list_length >= 3000) {
no_splits = round(list_length / 500)
chunks = split(store, 1:no_splits)
for (j in 1:no_splits) {
df_temp[j] = list(rbind.fill(chunks[[j]]))
}
df = rbind.fill(df_temp)
return(df)
}
else {
df = rbind.fill(store)
return(df)
}
}
dict_to_df(df_transaction[1])
a<-'{"cat_name": "Ella", "dwell_status": "tree_dweller", "coat_color": "gray, white, orange", "is_from_hell": "Y"}'
dict_to_df(a)
a<-df_transaction$totals[1:10]
a<-a%>%mutate(totals=gsub('\\',""))
a<-a%>%mutate(totals=gsub('\\\\',""))
a<-a%>%mutate(totals=gsub('\\\',""))
a[1]
a<-a%>%mutate(totals=gsub("\\\\","")
a[1]
a<-a%>%mutate(totals=gsub("\\\\","",totals)
a<-a%>%mutate(totals=gsub("\\\\","",totals)
a<-a%>%mutate(totals=gsub("\\\\","",totals))
a<-a%>%mutate(totals=gsub("\\\\","",totals))
a<-a%>%mutate(totals=gsub("\\\","",totals))
a<-a%>%mutate(totals=gsub("\\\\", "", str)
a[1]
t<-a[1]
gsub("\\\\", "", t)
b<-gsub("\\\\", "", t)
b
b<-gsub("\\\\\", "", t)
```{r}
dict_to_df = function(dict) {
require(plyr)
df = data.frame()
df_temp = list()
store = list()
for (i in 1:length(dict)) {
# Split up the dictionary entry
split = unlist(strsplit(dict[i], '\",'))
split = gsub('\\{', '', split)
split = gsub('\\}', '', split)
values = unlist(strsplit(split, ':'))
# Parse out what will be the df headers
headers = values[seq(1, length(values), 2)]
headers = gsub('\"', '', headers) # Remove quotes
headers = gsub(' ', '', headers)  # and whitespace
# Parse out what will be the df values
row_values = values[seq(0, length(values), 2)]
row_values = gsub('\"', '', row_values) # Remove quotes
row_values = gsub(' ', '', row_values)  # and whitespace
# Construct a dataframe with 1 row
out = data.frame(t(row_values))
colnames(out) = headers
store[i] = list(out)
if (i %% 1000 == 0) { print(round(i / length(dict), 2)) }
}
# rbind all the dataframes together into one dataframe
list_length = length(store)
# If the dictionary is sufficiently large rbind will be slow
# as all hell, so break the rbinding into multiple steps
if (list_length >= 3000) {
no_splits = round(list_length / 500)
chunks = split(store, 1:no_splits)
for (j in 1:no_splits) {
df_temp[j] = list(rbind.fill(chunks[[j]]))
}
df = rbind.fill(df_temp)
return(df)
}
else {
df = rbind.fill(store)
return(df)
}
}
b<-gsub("\\\\", "", t)
b<-gsub("\\\\", "", t)
b
t
b<-str. replace("\\", "",t)
my_str <- 'I am a \ backslash'
my_str <- gsub(
my_str <- gsub(
pattern = ('\\\\'),
replacement = '',
x = my_str
)
my_str <- 'I am a \ backslash'
my_str <- gsub(
pattern = ('\\\\'),
replacement = '',
x = my_str
)
x
my_str
my_str <- a[1]
my_str <- gsub(
pattern = ('\\\\'),
replacement = '',
x = my_str
)
my_str
class(my_str)
my_str <- as.string(a[1])
my_str <- as.character(a[1])
my_str <- gsub(
pattern = ('\\\\'),
replacement = '',
x = my_str
)
my_str
df_1<-df_transaction(totals=strsplit(as.character(totals),":"))%>%unnest(totals)
df_transaction<-df%>%filter(str_detect(totals,'transaction'))
a<-df_transaction$totals[1:10]
df_1<-df_transaction(totals=strsplit(as.character(totals),":"))%>%unnest(totals)
df_1<-df_transaction%>%(totals=strsplit(as.character(totals),":"))%>%unnest(totals)
df_1<-df_transaction%>%(totals=strsplit(as.character(totals),":"))%>%unnest(totals)
df_1<-df_transaction%>%(totals=strsplit(as.character(totals),":"))
df_1<-df_transaction$totals%>%(trsplit(,":"))
df_1<-df_transaction$totals%>%(strsplit(,":"))
strsplit(a,":")
a<-df_transaction$totals[1]
strsplit(a,":")
strsplit(a,":")%>%str_replace_all("\\","")
strsplit(a,":")%>%str_replace_all("\\\\","")
strsplit(a,":")%>%str_replace_all("","\\\\")
strsplit(a,":")%>%str_replace_all(" ","\\\\")
strsplit(a,":")%>%str_replace_all("\"\\\\\","")
dict_to_df = function(dict) {
require(plyr)
df = data.frame()
df_temp = list()
store = list()
for (i in 1:length(dict)) {
# Split up the dictionary entry
split = unlist(strsplit(dict[i], '\",'))
split = gsub('\\{', '', split)
split = gsub('\\}', '', split)
values = unlist(strsplit(split, ':'))
# Parse out what will be the df headers
headers = values[seq(1, length(values), 2)]
headers = gsub('\"', '', headers) # Remove quotes
headers = gsub(' ', '', headers)  # and whitespace
# Parse out what will be the df values
row_values = values[seq(0, length(values), 2)]
row_values = gsub('\"', '', row_values) # Remove quotes
row_values = gsub(' ', '', row_values)  # and whitespace
# Construct a dataframe with 1 row
out = data.frame(t(row_values))
colnames(out) = headers
store[i] = list(out)
if (i %% 1000 == 0) { print(round(i / length(dict), 2)) }
}
# rbind all the dataframes together into one dataframe
list_length = length(store)
# If the dictionary is sufficiently large rbind will be slow
# as all hell, so break the rbinding into multiple steps
if (list_length >= 3000) {
no_splits = round(list_length / 500)
chunks = split(store, 1:no_splits)
for (j in 1:no_splits) {
df_temp[j] = list(rbind.fill(chunks[[j]]))
}
df = rbind.fill(df_temp)
return(df)
}
else {
df = rbind.fill(store)
return(df)
}
}
strsplit(a,":")%>%str_replace_all("\"\\\\\,"")
strsplit(a,":")%>%str_replace_all("\\\\","")
strsplit(a,":")%>%str_replace_all('\"',"")
strsplit(a,":")%>%str_replace_all('\"',"")%>%str_remove("\\\\")
strsplit(a,":")%>%str_replace_all('\"',"")%>%str_remove_all("\\\\")
strsplit(a,":")%>%str_replace_all('\"',"")%>%str_remove_all("\\\\"&"\{|}")
strsplit(a,":")%>%str_replace_all('\"',"")%>%str_remove_all("\\\\")
