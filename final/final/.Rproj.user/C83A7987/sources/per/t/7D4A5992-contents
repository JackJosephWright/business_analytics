---
title: "final_initial"
author: "Jack Wright"
date: "10/22/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
library(tidyverse)
library(here)
```

```{r}
file<-here('kaggle_files','train.csv')
df_raw<-read.csv(file)
```

## Tidying 

## Columns overview

```{r}
colnames(df)
```

### ChannelGrouping

```{r}
df_raw$channelGrouping<-as.factor(df_raw$channelGrouping)

```



```{r}
levels(as.factor(df_raw$channelGrouping))

```


```{r}

```


## TOTALS column to Dataframe



```{r}
#function for turning python dictionary to a R dataframe

dict_df <-function(d){
  
}

dict_to_df = function(dict) {
  
  require(plyr)
  df = data.frame()
  df_temp = list()
  store = list()
  
  for (i in 1:length(dict)) {

    # Split up the dictionary entry
    split = unlist(strsplit(dict[i], '\",'))
    split = gsub('\\{', '', split)
    split = gsub('\\}', '', split)
    values = unlist(strsplit(split, ':'))

    # Parse out what will be the df headers
    headers = values[seq(1, length(values), 2)]       
    headers = gsub('\"', '', headers) # Remove quotes
    headers = gsub(' ', '', headers)  # and whitespace

    # Parse out what will be the df values
    row_values = values[seq(0, length(values), 2)]
    row_values = gsub('\"', '', row_values) # Remove quotes
    row_values = gsub(' ', '', row_values)  # and whitespace

    # Construct a dataframe with 1 row
    out = data.frame(t(row_values))
    colnames(out) = headers

    store[i] = list(out)

    if (i %% 1000 == 0) { print(round(i / length(dict), 2)) }

  }

    # rbind all the dataframes together into one dataframe 
    list_length = length(store)
    
    # If the dictionary is sufficiently large rbind will be slow
    # as all hell, so break the rbinding into multiple steps
    if (list_length >= 3000) {

      no_splits = round(list_length / 500)
      chunks = split(store, 1:no_splits)

      for (j in 1:no_splits) {

        df_temp[j] = list(rbind.fill(chunks[[j]]))
        
      }
      df = rbind.fill(df_temp)
      return(df)
    }

    else {

      df = rbind.fill(store)
      return(df)
    }

}

```

make dataframe for `totals` column

```{r}
df_total<-dict_to_df(df_raw$totals)
```



bind to raw data
```{r}
df<-cbind(df_raw%>%select(-totals),df_total)
```

## device

turn device column into dataframe

```{r}
df_raw$device[10]
```

```{r}
d<-"{\"browser\": \"Firefox\", \"browserVersion\": \"not available in demo dataset\", \"browserSize\": \"not available in demo dataset\", \"operatingSystem\": \"Windows\", \"operatingSystemVersion\": \"not available in demo dataset\", \"isMobile\": false, \"mobileDeviceBranding\": \"not available in demo dataset\", \"mobileDeviceModel\": \"not available in demo dataset\", \"mobileInputSelector\": \"not available in demo dataset\", \"mobileDeviceInfo\": \"not available in demo dataset\", \"mobileDeviceMarketingName\": \"not available in demo dataset\", \"flashVersion\": \"not available in demo dataset\", \"language\": \"not available in demo dataset\", \"screenColors\": \"not available in demo dataset\", \"screenResolution\": \"not available in demo dataset\", \"deviceCategory\": \"desktop\"}"


get_dict_items<-function(d){
 #gets dictionary items from a single cell
  #remove extraneous characters
  dict<-str_remove_all(d,'[\\"\\{\\}]')
  #split dict into list items
  d_list<-unlist(str_split(dict,","))
  #make column header list
  headers=str_extract(d_list,'(.+)(?=:)')
  #make value list
  values<-str_extract(d_list,'(?<=:)(.+)')
  
  output=rbind(values)
  colnames(output)<-headers
  
  return(output)
}

dict_to_df<-function(d){
  for (i in 1:length(d)){
  output=new_row
  new_row<-get_dict_items(d[i])
  test<-(output,new_row)
  }
  return(output)
}

```

```{r}
df_test<-sample_n(df_raw,10)
df_list<-as.list(df_test$totals)

dict_to_df(df_list)
```

