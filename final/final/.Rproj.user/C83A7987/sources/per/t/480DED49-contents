---
title: "Strings Notes"
author: "Jack Wright"
date: "9/8/2020"
output:
  html_document: default
  pdf_document: default
---
```{r}
library(tidyverse)
library(stringr)
```

String Examples
```{r}
string1<-"This is a string"
string2<-'To put a "quote" inside a string, use single quotes'

double_quote <- "\"" # or '"'
single_quote <- '\'' # or "'"
#literal backslash
x<-c("\"","\\")

#printed representation of a string is not the same as the string itself, try printing x and then using writeLines(x)
x
writeLines(x)
```

### Other Special Characters
see complete list by ?'"' or ?"'"



```{r}
#newline "\n" and tab "\t"

#non english characters
x <- "\u00b5"
x


```


### Multiple strings stored in a character vector

```{r}
c("one","two","three")
```


## String Length
str_length(..)

```{r}
str_length(c("a","R for data science", NA))
```


### See all stringr functions

type str_ 

once libary is loaded

### Combining Strings

str_c

```{r}
str_c("x","y")
str_c("x","y","z")

#control how they are separated

str_c("x","y","z",sep = ", ")

#if you want to print Missing values as NA, use str_replace_na()

x<-c("abc", NA)




str_c("|-", x, "-|")

str_c("|-", str_replace_na(x),"-|")

```


str_c is vectorized and automatically recycles shorter vectors to the same length as the longest:
```{r}

str_c("prefix-",c("a","b","c"),"-suffix")

```



Objects of length 0 are silently dropped. THis is useful in conjuntion with "if":

```{r}
name<-c("hadley","bill")
time_of_day<-"morning"
birthday<-FALSE

str_c("Good ", time_of_day," ",name, if(birthday)" and HAPPY BIRTHDAY",".")

```

### Collapse

collapse a vector of strings into a single string, use collapse


```{r}

str_c(c("x","y","z"), collapse = ", ")

# sep="..." doesnt work with vectors, collapse does


```



### Subsetting Strings

extract part of strings with 

str_sub()

str_sub()takes start and end arguments that give the (inclusive position of the substring)

Can also use the assignment form of str_sub() to modify strings

```{r}

x<-c("Apple","Banana","Pear")

str_sub(x,1,3)


#negative numbers count back from end

str_sub(x,-3,-1)

#Wont fail if too short, will just keep looping


#Use to modify strings

#EX- str_sub to pull first letters, in str_to_lower to lowercase, set "x" first letters calling str_sub again



str_sub(x,1,1)<-str_to_lower(str_sub(x,1,1))

x

```


### Locales

language codes. For example turkish has different upper and lower cases so you specify locale
```{r}
str_to_upper(c("i", "ı"))#dotless i

str_to_upper(c("i", "ı"), locale = "tr")
```



## Excersises

```{r}

x <- c("a", "b", "c", "d")
y <- c("w", "x", "y", "z")

paste(x,y,sep = "%%")
paste(x,y,sep="%%",collapse ="," )
paste(x,y,sep = ",",collapse = "%%")

x<-"ten4ten"

str_length(x)

```

str_wrap example
```{r}
x <- "heyho I am a very long string"    # Create a character string

str_wrap(x, 10)  

thanks_path <- file.path(R.home("doc"), "THANKS")
thanks <- str_c(readLines(thanks_path), collapse = "\n")
thanks <- word(thanks, 1, 3, fixed("\n\n"))
cat(str_wrap(thanks), "\n")
cat(str_wrap(thanks, width = 40), "\n")
cat(str_wrap(thanks, width = 60, indent = 2), "\n")
cat(str_wrap(thanks, width = 60, exdent = 2), "\n")
cat(str_wrap(thanks, width = 0, exdent = 2), "\n")



```


## Matching Patterns with Regular Expressions

Regexps
-allow you to describe patterns in strings.

-str_view()
-str_view_all()

these take a character vector and a regular expression and show if THEY MATCH

### Basic Matches
```{r}

x <- c("apple", "banana", "pear")
str_view(x, "an")

#Matches any character EXCEPT a newline
str_view(x,".a.")

#Matching a period

#Use regexp \. to indicate the character period and not its special behavior

#need to use \\. to escape the STRING and then ESCAPE the special behavior of the period

dot<-"\\."
writeLines(dot)

#Look for an explicit (will find a.c. )

str_view(c("abc","a.c","bef"), "a\\.c")

#Match literal backslash "\"

#need to write "\\\\"

x<-"a\"\'\\b"
writeLines(x)

str_view(x,"\"\'\\\\")



```


## Anchors

regexps will match any string. 

useful to ANCHOR the regexp so it matches from the start or end of a string.

^ to match the start of a string

$ to match the end of a string

### Mneumonic!
if you begin with power(^), you end up with money ($)

```{r}

x<-c("apple","banana","pear")
str_view(x,"^a")

str_view(x,"a$")

#Force a regular expression to only match a complete string, anchor with both ^ and $

x<-c("apple pie", "apple", "apple cake")
str_view(x, "apple")
str_view(x,"^apple$")

#match the boundary between words. like to keep things from pulling words from inside words

x<-c("summarize","summary","rowsum", "$^$")

str_view(x,"\\bsum\\b") #not right

```

### Excersizes

```{r}
#match literal string "$^$"

x<-c("summarize","summary","rowsum", "$^$")

str_view(x,"\\$\\^\\$")

test<-stringr::words

str_view(stringr::words,"x$",match=TRUE)

#Exactly 3 letters
str_view(stringr::words,"^...$", match=TRUE)

#Seven letters or more
str_view(stringr::words,"^.......", match=TRUE)

```

## Character Classes and Alternatives


special patterns that match more than one character.

\d matches any digit
\s matches any whitespace
[abc] matches a b or c
[^abc] matches anything EXCEPT a b or c

RECALL to create a regular expression containing \d or \s youll need to escape the \ for the string so type

"\\d" or "\\s"

use ALTERNATION to pic between one or more alternative patterns for example 

abc|d..f will match
"abc"
or 
"deaf"

EXAMPLE

```{r}
str_view(c("grey","gray"), "gr(e|a)y")
```

### Excercises
```{r}

#find all words that : 
x<-append(x,"orange")

#start with a vowel
str_view(x,"(^a|^e|^i|^o|^u)")


str_view(stringr::words,"(a|e|i|o|u)", match=FALSE)

str_view(stringr::words,"[^e]ed$", match=TRUE)


str_view(stringr::words, "ing$|ize$",match=TRUE)

str_view(stringr::words, "(cei|[e]ie)", match=TRUE)


str_view(c("91919191","917-544-1793","818-912-0932"),"\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d")

str_view(stringr::words,"q[^u]", match=TRUE)



```


### Repetition

Control how many times a pattern matches:

?: 0 or 1
+: 1 or more
*: 0 or more

```{r}

x<-"1888 is the longest year in the Roman numerals: MDCCCLXXXVIII "

str_view(x,"CC?")

str_view(x,"CC+")

str_view(x,"C[LX]+")



```

NOTE:

precedence of these operators is HIGH, so you can write 

colou?r to match either british or english. That means most uses will need parentheses like bana(na)+

you can also specify the number of matches precisely

{n}: exactly n
{n,}: n or more
{,m}: at most m
{n,m}: between n and m

```{r}
str_view(x, "C{2}")

str_view(x, "C{2,}") # 2 or more

str_view(x,"C{2,3}") # between 2 and 3 times

```

By default these matches are "greedy" meaning they will match the longest string possible. 

MAKE LAZY, matching the shortest string possible by putting "?" after them. 

```{r}
str_view(x, 'C{2,3}?')

str_view(x,'C[LX]+?')

```

### Grouping and Backreferences

parenthesis define "groups" you can refer to with backreferences, like \1 \2

EXAMPLE:
```{r}
# Finds all fruits that have a repeated pair of letters

str_view(fruit, "(..)\\1", match = TRUE)


str_view(stringr::words, "^(.).*\\1$", match=TRUE)

str_view(stringr::words,"(..).*\\1", match=TRUE)

str_view(stringr::words, "(.).*\\1.*\\1", match=TRUE)


```


## Tools

-Determine which strings match a pattern
-Find the position of matches
-Extract the content of matches
-Replace matches with new values
-Split a string based on a match

CAUTION:
"Some people, when confronted with a problem, think “I know, I’ll
use regular expressions.” Now they have two problems."

-See if you can break the problem down into smaller regular expressions

### Detect Matches

str_detect()
-Returns a logical vector the same length as the input

```{r}

x<-c("apple","banana","pear")
str_detect(x,"e")

#RECALL logical vectors are NUMERIC, so sum() and mean() work

#How many common words start with t?

sum(str_detect(stringr::words,"^t"))

#What proportion of common words end in a vowel?

mean(str_detect(stringr::words, '[aeiou]$'))

```
When you have complex logical conditions (e.g., match a or b but
not c unless d) it’s often easier to combine multiple str_detect()
calls with logical operators, rather than trying to create a single reg‐
ular expression. For example, here are two ways to find all words
that don’t contain any vowels:

2 ways to find words that don't contain any vowels:
```{r}
no_vowels_1<- !str_detect(words,"[aeiou]")

no_vowels_2 <- str_detect(words, "^[^aeiou]+$")

identical(no_vowels_1,no_vowels_2)

```

common use of str_detect() is to select elements that match a pattern.

Do ths with logical subsetting, or 

str_subset()

```{r}

words[str_detect(words,"x$")]

str_subset(words,"x$")

```
Typically strings will be in one column of dataFrame,
USE FILTER INSTEAD

```{r}
library(dplyr)
df<-tibble(word=words,
           i=seq_along(word))
df%>%filter(str_detect(words,"x$"))


```

### str_count()

instead of yes or no, counts HOW MANY matches are in a string

```{r}

x<-c("apple","banana","pear")
str_count(x,"a")


#on average how many vowels per word?

mean(str_count(words,"[aeiou]"))

#Use str_count with mutate

df%>%
  mutate(
    vowels=str_count(word,"[aeiou]"),
    consonants=str_count(word,"[^aeiou]")
  )

```
Note: str_count matches DONT OVERLAP



```{r}

str_count("abababa","aba")

str_view_all("abababa","aba")

```


Exercises

```{r}

#use single regular expression AND str_detect()

#find all words that start or end with x


#regex
words[str_detect(words,"^x|x$")]
#or split regex
start_with_x<-str_detect(words,"^x")
end_with_x<-str_detect(words,"x$")
words[start_with_x|end_with_x]

#all words that start with vowel end with consonant
#regex
togeth<-words[str_detect(words,"^[aeiou].*[^aeiou]$")]

#split regex
start_w_vowel<-str_detect(words,"^[aeiou]")
end_w_vowel<-str_detect(words,"[^aeiou]$")

split<-words[start_w_vowel &end_w_vowel]

identical(togeth,split)

#words contain each vowel?
#split
words[str_detect(words,"a") & str_detect(words,"e")& str_detect(words,"i")&str_detect(words,"o")& str_detect(words,"u")]


#what word has the highest number of vowels

vowels<-str_count(words,"[aeiou]")
words[which(vowels==max(vowels))]

#Highest PROPORTION of Vowels

prop_vowels<-str_count(words,"[aeiou]")/str_length(words)

words[which(prop_vowels==max(prop_vowels))]
```



## Extract Matches

str_extract()

extract actual TEXT of a match

```{r}

length(sentences)
head(sentences)

#find all sentences that contain a color

colors <- c(
 "red", "orange", "yellow", "green", "blue", "purple"
)
color_match <- str_c(colors, collapse = "|")
color_match

#now we can select the sentences that contain a color
#object with all the strings that contain a color
has_color<-str_subset(sentences,color_match)

#extract the color from the string that has color in it
matches<-str_extract(has_color, color_match)

```
#NOTE: str_extract() only extracts the FIRST match

HOW TO EXTRACT WHEN MORE THAN ONE MATCH

use str_extract_all()
-set simplify=TRUE 
return a matrix with short matches expanded to the same length as the longest match
```{r}

more<-sentences[str_count(sentences,color_match)>1]

str_view_all(more,color_match)
str_extract_all(more,color_match)

str_extract_all(more, color_match, simplify = TRUE)

x<-c("a"," a b ","a b c")
str_extract_all(x,"[a-z]",simplify = TRUE)


```

Excersizes

```{r}

# remove matches where the color is IN the word
color_match2<-str_c("\\b(",str_c(colors,collapse = "|"),")\\b")

has_color2<-str_subset(sentences,color_match2)

more2<-sentences[which(str_count(sentences,color_match2)>1)]

str_view_all(more2,color_match2,match=TRUE)


#first word from each sentence

str_extract(sentences,"[A-Za-z]+")%>%head()

#To catch words with an apostaphe
str_extract(sentences, "[A-Za-z][A-Za-z']*")%>%head()
#all words ending in "ing"

pattern<-"\\b[A-Za-z]+ing\\b"
sentences_w_ing<-str_detect(sentences,pattern)

str_extract_all(sentences[sentences_w_ing],pattern)%>%head()
#All plurals
pattern<-"[A-Za-z]{3,}s\\b"
sentences_w_plurals<-str_detect(sentences,pattern)

str_extract_all(sentences[sentences_w_plurals],pattern)%>%unique%>%unlist()%>%head()



```


## Grouped Matches

Use parenthesis for part of a complex match

EXAMPLE:
want to extract nouns from the sentences. i.e. any word that comes after "a" or "the"

define word by :
```{r}

noun<-"(a|the) ([^ ]+)"

has_noun<-sentences%>%
  str_subset(noun)%>%head(10)

has_noun%>%str_extract(noun)
```
str_match() gives each individual component. instead of a character vector like str_extract()

it returns a matrix with one column for the complete match followed by a column for each group

```{r}

has_noun%>%str_match(noun)

```


if data is a tibble, easier to use 
tidyr::extract(), but it requires you to name the matches, which are then placed in new columns:

```{r}
tibble(sentence = sentences) %>%
 tidyr::extract(
 sentence, c("article", "noun"), "(a|the) ([^ ]+)",
 remove = FALSE
 )


```

All matches for a string require str_match_all()

Excersizes
```{r}

#find all that come after number, like "one" or "two". pull number and word

numbers<-c("one","two","three","four","five","six","seven","eight","nine","ten")


numword <- "\\b(one|two|three|four|five|six|seven|eight|nine|ten) +(\\w+)"#\w is any "word character. so this gets all letters and apostrophes until the next space

sentences[str_detect(sentences,numword)]%>%
  str_extract(numword)

#find all contractions. separate out the pieces before and after the apostrophe

contPattern<-"([A-Za-z]+)'([a-z])+"

contSent<-sentences[str_detect(sentences,contPattern)]

str_extract_all(contSent,contPattern)%>%
  str_split("'")

```

## Replacing Matches

str_replace and str_replace_all() replace matches with new strings.

Simplest use is to replace pattern with a fixed string

```{r}

x<-c("apple","pear","banana")
str_replace(x,"[aeiou]","-")
str_replace_all(x,"[aeiou]","-")

```

Perform MULTIPLE replacements by giving a named vector to

str_replace_all()

```{r}
x<-c("1 house","2 cars","3 people")
str_replace_all(x,c("1"="one","2"="two","3"="three"))

```

USE BACKREFERENCES to insert components of the match. 

Example: flip the order of 2nd and 3rd words
```{r}

sentences %>%
 str_replace("([^ ]+) ([^ ]+) ([^ ]+)", "\\1 \\3 \\2") %>%
 head(5)

```


Excersizes
```{r}

#replace all forward slashes in a string with backslashes

testString<-"Hi/there/dude!"

testString%>%str_replace_all("/","\\\\")

#make str_to_lower() with replace_all()

#switch first and last letters in words, which of those are  STILL words

swapped<-str_replace_all(words,"^([a-z])(.*)([a-z])$","\\3\\2\\1")

intersect(swapped,words)

#ALTERNATE SOLUTION

swapped2<-str_replace_all(words,"^([[:alpha:]])(.*)([[:alpha:]]$)","\\3\\2\\1")

intersect(words,swapped2)
```


## Splitting

str_split()

split string into pieces

```{r}

sentences%>% 
  head(5)%>%
  str_split(" ")

```

because this example has differen number of pieces it returns a list. 

if working with a length-1 vector, EASIEST to extract the first element of the list:

can use simplify=TRUE to return a matrix

```{r}
"a|b|c|d" %>% str_split("\\|")%>%
.[[1]]
"a|b|c|d"%>%str_split("\\|",simplify=TRUE)

sentences %>%
 head(5) %>%
 str_split(" ", simplify = TRUE)

```

Request a MAX number of pieces

```{r}

fields <- c("Name: Hadley", "Country: NZ", "Age: 35")
fields %>% str_split(": ", n = 2, simplify = TRUE)


```

instead of splitting up string by PATTERN, 

can split by character, line, sentence, and word boundary()

```{r}
x<-"this is a sentence. This is another sentence."

str_view_all(x,boundary("word"))

str_split(x, " ")[[1]]

str_split(x,boundary("word"))[[1]]


```

Excersizes
```{r}

#split into components
string<-"apples, pears, bananas"

str_split(string, boundary("word"))[[1]]

str_split(string," ")[[1]]


```


## Find Matches

str_locate() and str_locate_all()

Gives starting and ending location of each match. 

Useful when none of the other functions does exactly what you want. 

Use str_locate() to find the matching pattern and str_sub() to extract or modify them.

## Other Types of Pattern

when you use a pattern that is a tring, it's automatically wrapped into a call to regex()

```{r}

# The regular call:
str_view(fruit,"nana")
#is shorthand for
str_view(fruit,regex("nana"))

```

can use other arguments of regex() to control details of the match:

ignore_case= TRUE 

allows characters to match either their uppercase or lowercase forms. This always uses current locale:

```{r}
bananas <- c("banana", "Banana", "BANANA")
str_view(bananas, "banana")

str_view(bananas, regex("banana", ignore_case = TRUE))

```

multiline=TRUE

allows ^ and $ to match the start and end of each line rather than the start and end of the complete string:

```{r}
x <- "Line 1\nLine 2\nLine 3"
str_extract_all(x, "^Line")[[1]]

str_extract_all(x, regex("^Line", multiline = TRUE))[[1]]

```

comments=TRUE 

allows you to use the comments and white space to make complex regular expressions more understandable.

spaces are ignored, as is everything after #. to match a literal space you need to escape it
"\\ "

```{r}

phone <- regex("
 \\(? # optional opening parens
 (\\d{3}) # area code
 [)- ]? # optional closing parens, dash, or space
 (\\d{3}) # another three numbers
 [ -]? # optional space or dash
 (\\d{3}) # three more numbers
 ", comments = TRUE)
str_match("514-791-8141", phone)

```

dotall= TRUE

allows "." to match everything including "\n"

fixed() 

matches exactly the specified sequence of bytes. 

## Other uses of Regular Expressions

apropos()

searches all objects available form the global environment. 

THIS IS USEFUL if you can't remember the name of the function

```{r}
apropos("replace")

```


dir() lists all the files in a directory. the "pattern" argument takes a regular expression and only returns filenames that match the pattern.

Example

find all R Markdown files in the current directory with:
```{r}
head(dir(pattern = "\\.Rmd$"))


```


## Stringi

stringr build on stringi package. 

stringi is comprehensive, WAY more functions. 


